'''
Created on 1 Aug 2014

@author: michael
'''

from mjb.dev.game_utility.collisions.rectangle_collider_picker import RectangleColliderPicker

class Shape(object):
    '''
    A shape must be able to calculate a representation of its shape as a list
    of rectangles according to various levels of precision.
    
    The shape's calculate method (calculate shape), returns rectangles more closely
    representing this shape - how closely depends on the precision. These rectangles assume
    the shape is rooted at (0,0).
    
    The shape's calculations for any given precision should always remain the same (immutable).
    To change this (such as in a rotation), change the shape held by the shape handler.
    '''

    def __init__(self, cache_depth=2):
        '''
        Construct a new shape calculator (use whatever constructor you want). You should call
        this if you are subclassing.
        @param cache_depth: will automatically cache calculations, keeping up the cache_depth calculations
        in the stack. This uses memory but significantly improves performance. This must not be negative.
        '''
        self.__cache_depth = cache_depth
        #Implemented as a list for speed (no particular care taken with who is stored)
        self.__cache = []
        
    def forget_cache(self):
        '''
        Forget any cached calculations. This is only relevant for freeing memory
        (and rarely worth your time)
        '''
        self.__cache = []
    
    def get_cache_depth(self):
        '''
        @return: the cache depth used by this shape
        '''
        return self.__cache_depth
    
    def set_cache_depth(self,cache_depth):
        '''
        @param cache_depth: the cache depth to use. Setting this will remove elements from the back
        of the effective stack (the calculations not used for the longest) if the cache_depth is reduced.
        This must not be negative.
        '''
        if self.__cache_depth>cache_depth:
            #Now pop elements to fit
            while len(self.__cache)>=cache_depth:
                self.__cache.pop()
        self.__cache_depth = cache_depth
    
    def calculate_shape(self,precision,include_collider=True):
        '''
        @param precision: the precision to which the shape should be calculated. Treat None as the lowest
        possible precision, and so should usually return the bounding rectangle. A value
        of 1 should be pixel perfect, and higher values are less precise.
        @param include_collider: will be true iff a collider for the shape should also be returned
        @return: a tuple pair as (rectangle_list,collider). Note that if include_collider=False, collider
        should be considered None (might not be if it was cached).
        The rectangle list will be a list of rectangles covering at least the entire
        shape rooted at (0,0) unlike the bounding rectangle. All of the rectangles in this list
        should fit within the bounding rectangle (if it were rooted at (0,0)), and each rectangle will have the form
        (x_min,y_min,x_max,y_max). If the collider is included, it will include exactly those rectangles (with None keys)
        '''
        if self.__cache_depth>0:
            for (p,res) in self.__cache:
                if (p==precision):
                    #Done!
                    return res
            #Not in the cache. Stick it in there!
            if len(self.__cache)==self.__cache_depth:
                self.__cache.pop()
            #Calculate the result in full...
            res = self.calculate_shape(precision, True)
            self.__cache.append((precision,res))
            return res
        #Cache not included.
        return self._calculate_shape_to_override(precision,include_collider)
    
    def _calculate_shape_to_override(self,precision,include_collider):
        '''
        This method's intended behaviour is identical to calculate shape's except this
        is meant to be overridden.
        '''
        pass
    
    def get_size(self):
        '''
        (You should override this)
        @return: the size of this shape as (width,height) as needed by shape handlers to form
        the bounding rectangle
        '''
        pass
    
    @staticmethod
    def calculate_default_collider(bounding_rectangle_size,rectangle_list):
        '''
        A convenience method to calculate the collider suitable from a list of rectangles.
        @param bounding_rectangle_size: the (width,height) of the bounding rectangle
        @param rectangle_list: the list of rectangles generated by calculate shape
        @return: a collider optimised to contain the given rectangles.
        '''
        #This method is here for convenience and to remove some duplication...
        collider = RectangleColliderPicker.get_recommended_collider(bounding_rectangle_size, len(rectangle_list))
        #Insert the rectangles...
        for (x_min,y_min,x_max,y_max) in rectangle_list:
            collider.insert_rectangle((x_min,y_min,x_max,y_max,None))
        return collider